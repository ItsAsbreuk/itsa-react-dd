<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/drag-drop.js - itsa-react-xxxxx</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="https://avatars0.githubusercontent.com/u/8314644?v=3&amp;s=84" title="itsa-react-xxxxx"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/DD.html">DD</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/drag.html">drag</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib/drag-drop.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Provides &#x60;drag and drop&#x60; functionality, without dropzones.
 * For &#x60;dropzone&#x60;-support, you should use the module: &#x60;drag-drop&#x60;.
 *
 *
 * &lt;i&gt;Copyright (c) 2014 ITSA - https://github.com/itsa&lt;/i&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 * @example
 * DD = require(&#x27;drag&#x27;)(WIN);
 * DD.init();
 *
 * @module drag
 * @class DD
 * @since 0.0.4
*/

require(&#x27;itsa-dom&#x27;);
require(&#x27;itsa-jsext&#x27;);

var DRAG = &#x27;drag&#x27;,
    DROP = &#x27;drop&#x27;,
    Event = require(&#x27;itsa-event&#x27;),
    idGenerator = require(&#x27;itsa-utils&#x27;).idGenerator,
    DATA_DRAGGABLE = &#x27;data-draggable&#x27;,
    CONSTRAIN_ATTR = DATA_DRAGGABLE+&#x27;-constrain&#x27;,
    DATA_DRAGGABLE_DROPTARGET = DATA_DRAGGABLE + &#x27;-droptarget&#x27;,
    MOUSE = &#x27;mouse&#x27;,
    EMITTER = &#x27;emitter&#x27;,
    DD_EMITTER = DATA_DRAGGABLE+&#x27;-&#x27;+EMITTER,
    DD_DRAG = DRAG,
    DD_DROP = DROP,
    DD_FAKE = &#x27;fake-&#x27;,
    DOWN = &#x27;down&#x27;,
    UP = &#x27;up&#x27;,
    MOVE = &#x27;move&#x27;,
    MOUSEUP = MOUSE+UP,
    MOUSEDOWN = MOUSE+DOWN,
    MOUSEMOVE = MOUSE+MOVE,
    TOUCH = &#x27;touch&#x27;,
    TOUCHSTART = TOUCH+&#x27;start&#x27;,
    TOUCHMOVE = TOUCH+MOVE,
    TOUCHEND = TOUCH+&#x27;end&#x27;,
    DD_FAKE_MOUSEUP = DD_FAKE+MOUSEUP,
    UI = &#x27;UI&#x27;,
    BORDER = &#x27;border&#x27;,
    WIDTH = &#x27;width&#x27;,
    BORDER_LEFT_WIDTH = BORDER+&#x27;-left-&#x27;+WIDTH,
    BORDER_TOP_WIDTH = BORDER+&#x27;-top-&#x27;+WIDTH,
    MARGIN_ = &#x27;margin-&#x27;,
    LEFT = &#x27;left&#x27;,
    RIGHT = &#x27;right&#x27;,
    TOP = &#x27;top&#x27;,
    BOTTOM = &#x27;bottom&#x27;,
    MARGIN_LEFT = MARGIN_+LEFT,
    MARGIN_RIGHT = MARGIN_+RIGHT,
    MARGIN_TOP = MARGIN_+TOP,
    MARGIN_BOTTOM = MARGIN_+BOTTOM,
    WINDOW = &#x27;window&#x27;,
    NO_OVERFLOW = &#x27;no-overflow&#x27;,
    ITSA_WINSCROLL = &#x27;data-itsa-winscroll&#x27;,
    DIRECTION_X = DATA_DRAGGABLE+&#x27;-x&#x27;,
    DIRECTION_Y = DATA_DRAGGABLE+&#x27;-y&#x27;,
    DRAGGABLE_GROUP = DATA_DRAGGABLE+&#x27;-group&#x27;,
    DRAGGABLE_HANDLE = DATA_DRAGGABLE+&#x27;-handle&#x27;,
    DRAGGABLE_PROXY = DATA_DRAGGABLE+&#x27;-proxy&#x27;,
    ITSA_DRAGGABLE = &#x27;[&#x27;+DATA_DRAGGABLE+&#x27;]&#x27;,
    VALID_PROXY = {
        &#x27;true&#x27;: true,
        &#x27;outline&#x27;: true,
        &#x27;blur&#x27;: true,
        &#x27;reverse-blur&#x27;: true
    };

module.exports = function(WIN) {

    // create global &#x60;_ITSA&#x60; if not created yet
    WIN._ITSA || Object.itsa_protectedProp(WIN, &#x27;_ITSA&#x27;, Object.create(null));

    if (WIN._ITSA.Drag) {
        return WIN._ITSA.Drag; // Drag was already created: don&#x27;t create multiple times
    }

    var mobileEvents = false,
        extendElement = require(&#x27;./extend-element&#x27;)(WIN),
        setXY = extendElement.setXY,
        transitionTo = extendElement.transitionTo,
        addClass = extendElement.addClass,
        removeClass = extendElement.removeClass,
        DOCUMENT = WIN.document,
        htmlNode = DOCUMENT.documentElement,
        HEAD = DOCUMENT.head,
        IE8_EVENTS = !htmlNode.addEventListener,
        DD, noScrollOnDrag, setListener, removeListener, stylenode, transitionCss;

    noScrollOnDrag = function(e) {
        if (e.target.matches(ITSA_DRAGGABLE) || e.target.itsa_inside(ITSA_DRAGGABLE)) {
            e.preventDefault();
        }
    };

    removeListener = function(evt, func) {
        if (IE8_EVENTS) {
            DOCUMENT.detachEvent(&#x27;on&#x27;+evt, func);
        }
        else {
            DOCUMENT.removeEventListener(evt, func, {capture: true, passive: false});
        }
    };

    setListener = function(evt, func) {
        if (IE8_EVENTS) {
            DOCUMENT.attachEvent(&#x27;on&#x27;+evt, func);
        }
        else {
            DOCUMENT.addEventListener(evt, func, {capture: true, passive: false});
        }
    };

    DD = {
        /**
         * Objecthash containing all specific information about the particular drag-cycle.
         * It has a structure like this:
         *
         * ddProps = {
         *     dragNode {HtmlElement} Element that is dragged
         *     x {Number} absolute x-position of the draggable inside &#x60;document&#x60; when the drag starts
         *     y {Number} absolute y-position of the draggable inside &#x60;document&#x60; when the drag starts
         *     inlineLeft {String} inline css of the property &#x60;left&#x60; when drag starts
         *     inlineTop {String} inline css of the property &#x60;top&#x60; when drag starts
         *     winConstrained {Boolean} whether the draggable should be constrained to &#x60;WIN&#x60;
         *     xMouseLast {Number} absolute x-position of the mouse inside &#x60;document&#x60; when the drag starts
         *     yMouseLast {Number} absolute y-position of the draggable inside &#x60;document&#x60; when the drag starts
         *     winScrollLeft {Number} the left-scroll of WIN when drag starts
         *     winScrollTop {Number} the top-scroll of WIN when drag starts
         *     constrain = { // constrain-properties when constrained to a HtmlElement
         *         xOrig {Number} x-position in the document, included with left-border-width
         *         yOrig {Number} y-position in the document, included with top-border-width
         *         x {Number} xOrig corrected with scroll-left of the constrained node
         *         y {Number} yOrig corrected with scroll-top of the constrained node
         *         w {Number} scrollWidth
         *         h {Number} scrollHeight
         *     };
         *     relatives[{ // Array with objects that represent all draggables that come along with the master-draggable (in case of multiple items), excluded the master draggable itself
         *         sourceNode {HtmlElement} original node (defined by drag-drop)
         *         dragNode {HtmlElement} draggable node
         *         shiftX {Number} the amount of left-pixels that this HtmlElement differs from the dragged element
         *         shiftY {Number} the amount of top-pixels that this HtmlElement differs from the dragged element
         *         inlineLeft {String} inline css of the property &#x60;left&#x60; when drag starts
         *         inlineTop {String} inline css of the property &#x60;top&#x60; when drag starts
         *     }]
         * }
         *
         * @property ddProps
         * @default {}
         * @type Object
         * @since 0.0.1
        */
        ddProps: {},

        /**
        * Default function for the &#x60;*:drag&#x60;-event
        *
        * @method _defFnDrag
        * @param e {Object} eventobject
        * @private
        * @since 0.0.1
        */
        _defFnDrag: function(e) {
            var ddProps = this.ddProps,
                dragNode = ddProps.dragNode,
                constrainNode = ddProps.constrainNode,
                winConstrained = ddProps.winConstrained,
                hasRelatives = !!ddProps.relatives,
                x, y, constrainX, constrainY, marginLeft, marginRight, marginTop, marginBottom,
                constrainX1, constrainX2, constrainY1, constrainY2;
            // is the drag is finished, there will be no ddProps.defined
            // return then, to prevent any events that stayed behind
            if (!ddProps.defined || !dragNode) {
                return;
            }

            // caution: the user might have put the mouse out of the screen and released the mousebutton!
            // If that is the case, the a mouseup-event should be initiated instead of draggin the element
            if (e.buttons===0) {
                // no more button pressed
                /**
                * Fired when the mouse comes back into the browser-WIN while drag was busy yet no buttons are pressed.
                * This is a correction to the fact that the mouseup-event wasn&#x27;t noticed because the mouse was outside the browser.
                *
                * @event fake-mouseup
                * @private
                * @since 0.1
                */
                Event.emit(dragNode, DD_FAKE_MOUSEUP);
            }
            else {
                // set it again: theoretically, the constrained node might move during dragging:
                if (constrainNode) {
                    marginLeft = parseInt(constrainNode.itsa_getStyle(MARGIN_LEFT), 10);
                    marginTop = parseInt(constrainNode.itsa_getStyle(MARGIN_TOP), 10);
                    marginRight = parseInt(constrainNode.itsa_getStyle(MARGIN_RIGHT), 10);
                    marginBottom = parseInt(constrainNode.itsa_getStyle(MARGIN_BOTTOM), 10);
                    constrainX = constrainNode.itsa_left -
                                 constrainNode.scrollLeft +
                                 parseInt(constrainNode.itsa_getStyle(BORDER_LEFT_WIDTH), 10) +
                                 marginLeft;
                    constrainY = constrainNode.itsa_top -
                                 constrainNode.scrollTop +
                                 parseInt(constrainNode.itsa_getStyle(BORDER_TOP_WIDTH), 10) +
                                 marginTop;
                    ddProps.constrain = {
                        x1: constrainX,
                        y1: constrainY,
                        x2: constrainX +
                            Math.min(constrainNode.scrollWidth, constrainNode.offsetWidth) -
                            dragNode.offsetWidth -
                            marginLeft -
                            marginRight,
                        y2: constrainY +
                            Math.min(constrainNode.scrollHeight, constrainNode.offsetHeight) -
                            dragNode.offsetHeight -
                            marginTop -
                            marginBottom
                    };
                }
                if (ddProps.xMovable) {
                    x = ddProps.x+e.xMouse+(winConstrained ? ddProps.winScrollLeft : WIN.itsa_getScrollLeft())-e.xMouseOrigin;
                }
                if (ddProps.yMovable) {
                    y = ddProps.y+e.yMouse+(winConstrained ? ddProps.winScrollTop : WIN.itsa_getScrollTop())-e.yMouseOrigin;
                }

                if (ddProps.constrain) {
                    constrainX1 = ddProps.constrain.x1;
                    constrainX2 = ddProps.constrain.x2;
                    constrainY1 = ddProps.constrain.y1;
                    constrainY2 = ddProps.constrain.y2;
                    if (hasRelatives) {
                        constrainX1 -= ddProps.relativesExtraConstrain.x1;
                        constrainX2 -= ddProps.relativesExtraConstrain.x2;
                        constrainY1 -= ddProps.relativesExtraConstrain.y1;
                        constrainY2 -= ddProps.relativesExtraConstrain.y2;
                    }
                    x = Math.min(Math.max(constrainX1, x), constrainX2);
                    y = Math.min(Math.max(constrainY1, y), constrainY2);
                }
                setXY(dragNode, x, y);

                hasRelatives &amp;&amp; ddProps.relatives.forEach(
                    function(item) {
                        setXY(item.dragNode, x+item.shiftX, y+item.shiftY);
                    }
                );
                ddProps.winConstrained || dragNode.itsa_forceIntoNodeView();
                constrainNode &amp;&amp; dragNode.itsa_forceIntoNodeView(constrainNode);
            }
        },

        /**
         * Default function for the &#x60;*:drop&#x60;-event
         *
         * @method _defFnDrop
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _defFnDrop: function(e) {
            var instance = this,
                dragNode = e.target,
                isCloned = dragNode._isCloned,
                originalDragNode = e.originalDragNode,
                dropTarget = e.dropTarget,
                node, relatives;

            // unset a data-attribute to &#x60;htmlNode&#x60;
            htmlNode.removeAttribute(DATA_DRAGGABLE_DROPTARGET);
            if (isCloned) {
                // remove proxynode and set original node to the right position:
                instance._removeProxyNode(dragNode, originalDragNode);
                // same for all relatives:
                e.originalRelativeRefs &amp;&amp; e.originalRelativeRefs.forEach(function(obj) {
                    instance._removeProxyNode(obj.proxyNode, obj.node);
                });
            }
            // if we have a droptarget, we might need to reposution:
            if (dropTarget) {
                // we might need to reposition the node (or nodes!) a bit in order to make the fit inside the dropzone
                if (isCloned) {
                    node = originalDragNode;
                    relatives = e.originalRelativeRefs;
                }
                else {
                    node = dragNode;
                    relatives = e.relatives;
                }
                relatives &amp;&amp; relatives.forEach(function(obj) {
                    var dragNodeRel = obj[isCloned ? &#x27;node&#x27; : &#x27;dragNode&#x27;];
                    transitionTo(dragNodeRel, dragNodeRel.itsa_left, dragNodeRel.itsa_top, dropTarget);
                });
                return transitionTo(node, node.itsa_left, node.itsa_top, dropTarget); // make it e.returnValue so that afterlisteners can wait
            }
        },

        /**
         * Default function for the &#x60;*:dd&#x60;-event
         *
         * @method _defFnStart
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _defFnStart: function(e) {
            var instance = this,
                customEventDrag = e.emitter + &#x27;:&#x27;+DD_DRAG,
                customEventDrop = e.emitter + &#x27;:&#x27;+DD_DROP;

            Event.defineEvent(customEventDrag)
                .defaultFn(instance._defFnDrag.bind(instance));
            Event.defineEvent(customEventDrop)
                .defaultFn(instance._defFnDrop.bind(instance))
                .preventedFn(instance._prevFnDrop.bind(instance));
            // DOCUMENT.getAll(&#x27;.&#x27;+DD_MASTER_CLASS).removeClass(DD_MASTER_CLASS);
            instance._initializeDrag(e);
            return e.draggable;
        },

        /**
        * Defines the definition of the &#x60;dd&#x60; event: the first phase of the drag-eventcycle (dd, *:drag, *:drop)
        *
        * @method _defineDDStart
        * @param emitterName {String} the emitterName, which leads into the definition of event &#x60;emitterName:dd&#x60;
        * @private
        * @since 0.0.1
        */
        _defineDDStart: function(emitterName) {
            var instance = this;
            // by using dd before drag, the user can create a &#x60;before&#x60;-subscriber to dd
            // and define e.emitter and/or e.relatives before going into &#x60;drag&#x60;
            // If event already exists, no action will be taken internally
            Event.defineEvent(emitterName+&#x27;:dd&#x27;)
                .defaultFn(instance._defFnStart.bind(instance))
                .preventedFn(instance._prevFnStart.bind(instance));
        },

        /**
         * Default function for the &#x60;*:drag&#x60;-event
         *
         * @method _initializeDrag
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _initializeDrag: function(e) {
            var instance = this,
                dragNode = e.dragNode,
                constrain = dragNode.getAttribute(CONSTRAIN_ATTR),
                directionX = dragNode.getAttribute(DIRECTION_X) || &#x27;&#x27;,
                directionY = dragNode.getAttribute(DIRECTION_Y) || &#x27;&#x27;,
                group = dragNode.getAttribute(DRAGGABLE_GROUP),
                ddProps = instance.ddProps,
                emitterName = e.emitter,
                x, y, constrainNode, winConstrained, winScrollLeft, winScrollTop, moveFn, releaseFn,
                extraClass, groupNodes, parentNode, difX1, difX2, difY1, difY2, dragNodeLeft,
                dragNodeRight, dragNodeTop, dragNodeBottom, proxy, dropTarget;

            moveFn = function(e2) {
                var firstTouch;
                if (e2.touches &amp;&amp; (firstTouch=e2.touches[0])) {
                    e2.clientX = firstTouch.clientX;
                    e2.clientY = firstTouch.clientY;
                }
                if (instance.ddProps.itsa_isEmpty() || !e2.clientX) {
                    return;
                }
                // move the object
                e.xMouse = e2.clientX;
                e.yMouse = e2.clientY;
                /**
                * Emitted during the drag-cycle of a draggable Element (while it is dragged).
                *
                * @event *:drag
                * @param e {Object} eventobject including:
                * @param e.target {HtmlElement} the HtmlElement that is being dragged
                * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
                * @param e.sourceTarget {HtmlElement} the deepest HtmlElement where the mouse lies upon
                * @param e.dd {Promise} Promise that gets fulfilled when dragging is ended. The fullfilled-callback has no arguments.
                * @param e.xMouse {Number} the current x-position in the WIN-view
                * @param e.yMouse {Number} the current y-position in the WIN-view
                * @param e.clientX {Number} the current x-position in the WIN-view
                * @param e.clientY {Number} the current y-position in the WIN-view
                * @param e.xMouseOrigin {Number} the original x-position in the document when drag started (incl. scrollOffset)
                * @param e.yMouseOrigin {Number} the original y-position in the document when drag started (incl. scrollOffset)
                * @param [e.relatives] {NodeList} an optional list that the user could set in a &#x60;before&#x60;-subscriber of the &#x60;dd&#x60;-event
                *        to inform which nodes are related to the draggable node and should be dragged as well.
                * @since 0.1
                */
                Event.emit(dragNode, emitterName+&#x27;:&#x27;+DD_DRAG, e);
                e.draggable.callback();
            };

            releaseFn = function(e2) {
                var dragNode = instance.ddProps.dragNode,
                    firstTouch;
                // remove listener for &#x60;mousemove&#x60; and &#x60;mouseup&#x60;
                removeListener(mobileEvents ? TOUCHMOVE : MOUSEMOVE, moveFn);
                removeListener(mobileEvents ? TOUCHEND : MOUSEUP, releaseFn);

                // set mousepos for the last time:
                if (e2.changedTouches &amp;&amp; (firstTouch=e2.changedTouches[0])) {
                    e2.clientX = firstTouch.clientX;
                    e2.clientY = firstTouch.clientY;
                }
                e.xMouse = e2.clientX;
                e.yMouse = e2.clientY;

                if (constrain &amp;&amp; ddProps.winConstrained) {
                    // if constrained to WIN:
                    // remove overflow=hidden from the bodynode
                    htmlNode.removeAttribute(ITSA_WINSCROLL);
                }

                // modify event with properties we need inside dd:drop:
                e.originalDragNode = instance.ddProps.originalDragNode;
                e.originalRelativeRefs = instance.ddProps.originalRelativeRefs;
                e.relatives = instance.ddProps.relatives;
                e.originalX = instance.ddProps.x;
                e.originalY = instance.ddProps.y;

                instance.ddProps = {};
                /**
                * Emitted when drag-cycle of a draggable Element is ended.
                *
                * @event *:drop
                * @param e {Object} eventobject including:
                * @param e.target {HtmlElement} the HtmlElement that is being dragged
                * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
                * @param e.sourceTarget {HtmlElement} the deepest HtmlElement where the mouse lies upon
                * @param e.dd {Promise} Promise that gets fulfilled when dragging is ended. The fullfilled-callback has no arguments.
                * @param e.xMouse {Number} the current x-position in the WIN-view
                * @param e.yMouse {Number} the current y-position in the WIN-view
                * @param e.clientX {Number} the current x-position in the WIN-view
                * @param e.clientY {Number} the current y-position in the WIN-view
                * @param e.xMouseOrigin {Number} the original x-position in the document when drag started (incl. scrollOffset)
                * @param e.yMouseOrigin {Number} the original y-position in the document when drag started (incl. scrollOffset)
                * @param [e.relatives] {NodeList} an optional list that the user could set in a &#x60;before&#x60;-subscriber of the &#x60;dd&#x60;-event
                *        to inform which nodes are related to the draggable node and should be dragged as well.
                * @since 0.1
                */

                Event.emit(dragNode, emitterName+&#x27;:&#x27;+DD_DROP, e);

                e.draggable.fulfill();
            };

            // check if we need to make a proxy-node:
            proxy = (e.dragNode.getAttribute(DRAGGABLE_PROXY) || &#x27;&#x27;).toLowerCase();
            if (VALID_PROXY[proxy]) {
                parentNode = dragNode.parentNode;
                ddProps.originalDragNode = dragNode;
                dragNode = dragNode.cloneNode(proxy!==&#x27;outline&#x27;);
                dragNode._isCloned = true; // let &#x60;setXY&#x60; know that were moving a cloned node
                // let &#x60;setXY&#x60; know that were moving a cloned node; either by &#x60;true&#x60; or specifying the groupname:
                dragNode._isReverseCloned = (proxy===&#x27;reverse-blur&#x27;) &amp;&amp; (group || true);
                if (proxy===&#x27;outline&#x27;) {
                    extraClass = &#x27;itsacss-cloned-node-outline&#x27;;
                }
                else if (proxy===&#x27;blur&#x27;) {
                    extraClass = &#x27;itsacss-cloned-node-blurred&#x27;;
                }
                instance._insertProxyNode(parentNode, dragNode, ddProps.originalDragNode.itsa_left, ddProps.originalDragNode.itsa_top, extraClass);
                if (group) {
                    ddProps.originalRelativeRefs = [];
                    groupNodes = DOCUMENT.itsa_getAll(&#x27;[&#x27;+DRAGGABLE_GROUP+&#x27;=&quot;&#x27;+group+&#x27;&quot;]:not(.itsacss-cloned-node)&#x27;); // returns an array-like object
                    Array.prototype.forEach.call(groupNodes, function(node) {
                        var proxyNode;
                        if (node!==ddProps.originalDragNode) {
                            proxyNode = node.cloneNode(true);
                            ddProps.originalRelativeRefs.push({
                                node: node,
                                proxyNode: proxyNode
                            });
                            proxyNode._isCloned = true; // let &#x60;setXY&#x60; know that were moving a cloned node
                            instance._insertProxyNode(node.parentNode, proxyNode, node.itsa_left, node.itsa_top, extraClass);
                        }
                    });
                }
            }
            // define ddProps --&gt; internal object with data about the draggable instance
            ddProps.dragNode = dragNode;
            if (directionX || directionY) {
                ddProps.xMovable = (directionX.toLowerCase()===&#x27;true&#x27;);
                ddProps.yMovable = (directionY.toLowerCase()===&#x27;true&#x27;);
            }
            else {
                ddProps.xMovable = ddProps.yMovable = true;
            }
            ddProps.x = x = dragNode.itsa_left;
            ddProps.y = y = dragNode.itsa_top;
            ddProps.winConstrained = winConstrained = (constrain===WINDOW);
            ddProps.xMouseLast = x;
            ddProps.yMouseLast = y;
            if (constrain) {
                if (winConstrained) {
                    ddProps.winScrollLeft = winScrollLeft = WIN.itsa_getScrollLeft();
                    ddProps.winScrollTop = winScrollTop = WIN.itsa_getScrollTop();
                    ddProps.constrain = {
                        x1: winScrollLeft,
                        y1: winScrollTop,
                        x2: winScrollLeft+WIN.itsa_getWidth()-dragNode.offsetWidth,
                        y2: winScrollTop+WIN.itsa_getHeight()-dragNode.offsetHeight
                    };
                    // if constrained to WIN:
                    // set a class that makes overflow hidden --&gt; this will prevent
                    // some browsers from scrolling the WIN when a pressed mouse
                    // gets out of the WIN

                    // TODO:
                    htmlNode.setAttribute(ITSA_WINSCROLL, NO_OVERFLOW);

                }
                else {
                    constrainNode = dragNode.itsa_inside(constrain);
                    // if there is a match, then make sure x and y fall within the region
                    if (constrainNode) {
                        ddProps.constrainNode = constrainNode;
                    }
                }
            }

            // create listener for &#x60;mousemove&#x60; and transform it into the &#x60;*:dd:drag&#x60;-event
            setListener(mobileEvents ? TOUCHMOVE : MOUSEMOVE, moveFn);
            // Event.onceAfter([mobileEvents ? TOUCHEND : MOUSEUP, DD_FAKE_MOUSEUP], function(e3) {
            setListener(mobileEvents ? TOUCHEND : MOUSEUP, releaseFn);

            setXY(dragNode, ddProps.xMouseLast, ddProps.yMouseLast);

            if (group) {
                // relatives are extra HtmlElements that should be moved aside with the main dragged element
                // e.relatives is a selector, e.relativeNodes will be an array with nodes
                // in case of proxy: only take into account the nodes that are cloned (proxy-nodes)
                groupNodes = DOCUMENT.itsa_getAll(&#x27;[&#x27;+DRAGGABLE_GROUP+&#x27;=&quot;&#x27;+group+&#x27;&quot;]&#x27;+(dragNode._isCloned ? &#x27;.itsacss-cloned-node&#x27; : &#x27;&#x27;)); // returns an array-like object
                // because ES5 doesn&#x27;t have Array.filter, we will fill the array &#x60;relativeNodes&#x60; manually
                e.relativeNodes = [];
                ddProps.relatives = [];
                if (constrain) {
                    ddProps.relativesExtraConstrain = { // correction for positions of the other nodes
                        x1: 0,
                        x2: 0,
                        y1: 0,
                        y2: 0
                    };
                    dragNodeLeft = dragNode.itsa_left;
                    dragNodeRight = dragNode.itsa_right;
                    dragNodeTop = dragNode.itsa_top;
                    dragNodeBottom = dragNode.itsa_bottom;
                }
                Array.prototype.forEach.call(groupNodes, function(node) {
                    var item;
                    if (node!==dragNode) {
                        e.relativeNodes.push(node);
                        item = {
                            dragNode: node,
                            shiftX: node.itsa_left - x,
                            shiftY: node.itsa_top - y
                        };
                        ddProps.relatives.push(item);
                        // we might need to reassign the constrain values:
                        if (constrain) {
                            difX1 = node.itsa_left - dragNodeLeft;
                            difX2 = node.itsa_right - dragNodeRight;
                            difY1 = node.itsa_top - dragNodeTop;
                            difY2 = node.itsa_bottom - dragNodeBottom;
                            ddProps.relativesExtraConstrain.x1 = Math.min(ddProps.relativesExtraConstrain.x1, difX1);
                            ddProps.relativesExtraConstrain.x2 = Math.max(ddProps.relativesExtraConstrain.x2, difX2);
                            ddProps.relativesExtraConstrain.y1 = Math.min(ddProps.relativesExtraConstrain.y1, difY1);
                            ddProps.relativesExtraConstrain.y2 = Math.max(ddProps.relativesExtraConstrain.y2, difY2);
                        }
                    }
                });
                if (ddProps.relatives.length===0) {
                    delete ddProps.relatives;
                }
            }

            // in case of having a drop-target, we set a data-attribute to &#x60;head&#x60;, so that anyone interested gets informed by css:
            dropTarget = dragNode.getAttribute(DATA_DRAGGABLE_DROPTARGET);
            dropTarget &amp;&amp; htmlNode.setAttribute(DATA_DRAGGABLE_DROPTARGET, dropTarget);
        },

        _insertProxyNode: function(parentNode, node, x, y, extraClass) {
            addClass(node, [&#x27;itsacss-cloned-node&#x27;, &#x27;itsacss-display-block&#x27;, &#x27;itsacss-position-absolute&#x27;, &#x27;itsacss-invisible&#x27;]);
            extraClass &amp;&amp; addClass(node, extraClass);
            parentNode.appendChild(node);
            setXY(node, x, y);
            removeClass(node, &#x27;itsacss-invisible&#x27;);
        },

        /**
         * Prevented function for the &#x60;*:drop&#x60;-event
         *
         * @method _prevFnDrop
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _prevFnDrop: function(e) {
            var instance = this,
                dragNode = e.target,
                x, y;

            // in case of having a drop-target, we unset a data-attribute to &#x60;htmlNode&#x60;
            htmlNode.removeAttribute(DATA_DRAGGABLE_DROPTARGET);
            if (dragNode._isCloned) {
                // same for all relatives:
                e.originalRelativeRefs &amp;&amp; e.originalRelativeRefs.forEach(function(obj) {
                    instance._revertProxyNode(obj.proxyNode, obj.node);
                });
                // remove proxynode and set original node to the right position:
                return instance._revertProxyNode(dragNode, e.originalDragNode);
            }
            // remove proxynode and set original node to the right position:
            x = e.originalX;
            y = e.originalY;
            // same for all relatives:
            e.relatives &amp;&amp; e.relatives.forEach(function(obj) {
                instance._revertNode(obj.dragNode, x+obj.shiftX, y+obj.shiftY);
            });
            return instance._revertNode(dragNode, x, y);
        },

        /**
         * Prevented function for the &#x60;*:start&#x60;-event
         *
         * @method _prevFnStart
         * @param e {Object} eventobject
         * @private
         * @since 0.0.1
         */
        _prevFnStart: function(e) {
            e.draggable.reject();
        },

        _removeProxyNode: function(node, originalDragNode) {
            setXY(originalDragNode, node.itsa_left, node.itsa_top);
            // remove the opacity of the original node:
            node._isReverseCloned &amp;&amp; setXY(node, node.itsa_left, node.itsa_top, true);
            node.parentNode.removeChild(node);
        },

        _revertProxyNode: function(node, originalDragNode) {
            // set the position of the proxy back
            // transition the proxy back to its original position:
            var instance = this;
            instance._isReverting = true;
            return transitionTo(node, originalDragNode.itsa_left, originalDragNode.itsa_top).itsa_finally(function() {
                // remove the opacity of the original node:
                node._isReverseCloned &amp;&amp; setXY(node, node.itsa_left, node.itsa_top, true);
                node.parentNode.removeChild(node);
                instance._isReverting = false;
            });
        },

        _revertNode: function(node, x, y) {
            // transition the proxy back to its original position:
            var instance = this;
            instance._isReverting = true;
            return transitionTo(node, x, y).itsa_finally(function() {
                // remove the opacity of the original node:
                setXY(node, x, y, true);
                instance._isReverting = false;
            });
        },

        /**
        * Engine behind the drag-drop-cycle.
        * Sets up a &#x60;mousedown&#x60; listener to initiate a drag-drop eventcycle. The eventcycle start whenever
        * one of these events happens on a HtmlElement with the attribute data-draggable=&quot;true&quot;&#x60;.
        * The drag-drop eventcycle consists of the events: &#x60;start&#x60;, &#x60;emitterName:drag&#x60; and &#x60;emitterName:drop&#x60;
        *
        *
        * @method init
        * @private
        * @since 0.0.1
        */
        init: function() {
            var instance = this,
                nodeTargetFn, setMobileEventSupport;

            setMobileEventSupport = function() {
                removeListener(MOUSEDOWN, nodeTargetFn);
                mobileEvents = true;
            };

            nodeTargetFn = function(e) {
                var node = e.target,
                    isDraggable = node.matchesSelector(ITSA_DRAGGABLE),
                    handle, emitterName, parentDragNode, handleMatch, parentHandleNode, firstTouch;

                parentDragNode = !isDraggable &amp;&amp; node.itsa_inside(ITSA_DRAGGABLE);
                if ((e.which&lt;2) &amp;&amp; !instance._isReverting &amp;&amp; (isDraggable || parentDragNode)) {
                    e.dragNode = parentDragNode || node;
                    if (e.touches &amp;&amp; (firstTouch=e.touches[0])) {
                        e.clientX = firstTouch.clientX;
                        e.clientY = firstTouch.clientY;
                    }

                    // first check if there is a handle to determine if the drag started here:
                    handle = e.dragNode.getAttribute(DRAGGABLE_HANDLE);
                    if (handle) {
                        handleMatch = node.matchesSelector(handle);
                        // if no match then the click could still be on a descendent node:
                        if (!handleMatch &amp;&amp; parentDragNode) {
                            parentHandleNode = node.itsa_inside(handle);
                            e.handleNode = parentHandleNode.itsa_inside(parentDragNode);
                        }
                        else {
                            e.handleNode = handleMatch &amp;&amp; node;
                        }
                        if (!e.handleNode) {
                            return;
                        }
                    }

                    // initialize ddProps: have to do here, because the event might not start because it wasn&#x27;t inside the handle when it should be
                    instance.ddProps = {
                        defined: true,
                        dragOverList: []
                    };

                    // add &#x60;drag&#x60;-Promise to the eventobject --&gt; this Promise will be resolved once the pointer has released.
                    e.draggable = Promise.itsa_manage();
                    e.draggable.catch(function(err) {
                        console.warn(&#x27;draggable rejected: &#x27;+err);
                    });

                    // define e.setOnDrag --&gt; users
                    e.setOnDrag = function(callbackFn) {
                        e.draggable.setCallback(callbackFn);
                    };
                    // store the orriginal mouseposition:
                    e.xMouseOrigin = e.clientX + WIN.itsa_getScrollLeft();
                    e.yMouseOrigin = e.clientY + WIN.itsa_getScrollTop();

                    // set the emitterName:
                    emitterName = e.dragNode.getAttribute(DD_EMITTER) || UI;
                    // now we can start the eventcycle by emitting emitterName:dd:
                    /**
                    * Emitted when a draggable Element&#x27;s drag-cycle starts. You can use a &#x60;before&#x60;-subscriber to specify
                    * e.relatives, which should be a nodelist with HtmlElements, that should be dragged togehter with the master
                    * draggable Element.
                    *
                    * @event *:dd
                    * @param e {Object} eventobject including:
                    * @param e.target {HtmlElement} the HtmlElement that is being dragged
                    * @param e.currentTarget {HtmlElement} the HtmlElement that is delegating
                    * @param e.sourceTarget {HtmlElement} the deepest HtmlElement where the mouse lies upon
                    * @param e.dd {Promise} Promise that gets fulfilled when dragging is ended. The fullfilled-callback has no arguments.
                    * @param e.xMouse {Number} the current x-position in the WIN-view
                    * @param e.yMouse {Number} the current y-position in the WIN-view
                    * @param e.clientX {Number} the current x-position in the WIN-view
                    * @param e.clientY {Number} the current y-position in the WIN-view
                    * @param e.xMouseOrigin {Number} the original x-position in the document when drag started (incl. scrollOffset)
                    * @param e.yMouseOrigin {Number} the original y-position in the document when drag started (incl. scrollOffset)
                    * @param [e.relatives] {NodeList} an optional list that the user could set in a &#x60;before&#x60;-subscriber of the &#x60;dd&#x60;-event
                    *        to inform which nodes are related to the draggable node and should be dragged as well.
                    * @since 0.1
                    */
                    instance._defineDDStart(emitterName);
                    Event.emit(e.target, emitterName+&#x27;:dd&#x27;, e);
                }
            };

            if (!instance._initiated) {
                instance._initiated = true;

                setListener(MOUSEDOWN, nodeTargetFn); // remove this listener in case of TOUCHSTART is active (mobile):
                setListener(TOUCHSTART, setMobileEventSupport);
                setListener(TOUCHSTART, nodeTargetFn);

                // prevent default behaviour on scrolling: otherwise mobile devices will scroll instead of drag:
                // scrollPreventListener = Event.before(&#x27;panstart&#x27;, function(e) {e.preventDefaultContinue();});
                // scrollPreventListener = Event.before(&#x27;touchmove&#x27;, function(e) {e.preventDefault();});

                setListener(&#x27;touchstart&#x27;, noScrollOnDrag);
                setListener(&#x27;touchmove&#x27;, noScrollOnDrag);
            }
        }
    };

    // don&#x27;t drag when the cursor is above an input, text, or editable element:
    Event.before(
        &#x27;*:&#x27;+DD_DRAG,
        function(e) {
            e.preventDefault();
        },
        function(e) {
            var sourceNode= e.target,
                tagName = sourceNode.tagName;
            return (tagName===&#x27;INPUT&#x27;) || (tagName===&#x27;TEXTAREA&#x27;) || (sourceNode.getAttribute(&#x27;contenteditable&#x27;)===&#x27;true&#x27;);
        }
    );

    // don&#x27;t drag any native drag-drop items when they are part of dd, because they prevent they corrupt dragging:
    setListener(&#x27;dragstart&#x27;, function(e) {
        if (e.target.matchesSelector(ITSA_DRAGGABLE) || e.target.itsa_inside(ITSA_DRAGGABLE)) {
            e.preventDefault();
        }
    });

    // declare a global style:
    stylenode = DOCUMENT.createElement(&#x27;style&#x27;);
    stylenode.setAttribute(&#x27;type&#x27;, &#x27;text/css&#x27;);
    HEAD.appendChild(stylenode);
    transitionCss = &#x27;transition: top 0.25s ease-out, left 0.25s ease-out, transform 0.25s ease-out !important;&#x27;;
    stylenode.textContent = &#x27;html[&#x27;+ITSA_WINSCROLL+&#x27;=&quot;&#x27;+NO_OVERFLOW+&#x27;&quot;] body {\noverflow: hidden !important;\n}\n&#x27; +
                            &#x27;.itsacss-invisible {\nopacity: 0 !important; left: -9999px !important; top: -9999px !important; z-index: -1001 !important;}\n&#x27; +
                            &#x27;.itsacss-display-block {\ndisplay: block !important;}\n&#x27; +
                            &#x27;.itsacss-position-absolute {\nposition: absolute !important;}\n&#x27; +
                            &#x27;div[&#x27;+DATA_DRAGGABLE+&#x27;].itsacss-drag-revert-trans {\n-webkit-&#x27;+ transitionCss +
                                                         &#x27; -moz-&#x27; + transitionCss +
                                                         &#x27; -ms-&#x27; + transitionCss +
                                                         &#x27; -o-&#x27; + transitionCss +
                                                         &#x27; &#x27; + transitionCss + &#x27;}\n&#x27; +
                            &#x27;.itsacss-cloned-node-outline {\nbox-shadow: 0 0 0 1px #333 inset !important; background: transparent !important}\n&#x27; +
                            &#x27;.itsacss-cloned-node-blurred {\nopacity: 0.6;filter: alpha(opacity=60);}\n&#x27;;

    DD.init();
    WIN._ITSA.Drag = DD;

    Event.before(&#x27;*:drop&#x27;, function(e) {
        var liesInsideNode, dropZones, x, y, dropTargets,
            dragNode = e.dragNode,
            dropTarget = dragNode.getAttribute(DATA_DRAGGABLE_DROPTARGET);
        if (dropTarget) {
            // split droptarget into an array: we might have specified more than 1 target
            dropTargets = dropTarget.split(&#x27;,&#x27;).map(function(item) {
                return item.itsa_trim();
            });
            // only accept drop if the draggable node is released above a droptarget
            // first, we need to find all the dropzones:
            dropZones = DOCUMENT.itsa_getAll(&#x27;[data-dropzone]&#x27;);
            x = e.xMouse;
            y = e.yMouse;
            // next, check if the position lies within at least one of the dropzones:
            Array.prototype.some.call(dropZones, function(dropZoneNode) {
                if (dropTargets.itsa_contains(dropZoneNode.getAttribute(&#x27;data-dropzone&#x27;)) &amp;&amp; dropZoneNode.itsa_insidePos(x, y)) {
                    liesInsideNode = dropZoneNode;
                }
                return liesInsideNode;
            });
            if (!liesInsideNode) {
                e.preventDefault(); // will revert the draggable node to its original position
            }
            else {
                e.dropTarget = liesInsideNode;
            }
        }
    });

    return {
        generateId: function() {
            return idGenerator(&#x27;itsa-dd&#x27;);
        }
    };
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
